{"version":3,"file":"static/js/485.f57389b4.chunk.js","mappings":"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","sources":["worker/format/Types.ts","worker/format/Synergy.ts","worker/ImportWorker.ts"],"sourcesContent":["export enum ReadingStatusEnum {\n  Unknown,\n  NotAvailable,\n  Actual\n}\n\nexport type Entry = {\n  date : Date;\n  time : number;\n  kWhIn : number;\n  kWhOut : number;\n  readingStatus: ReadingStatusEnum;\n}\n\nexport interface ExtraFields {\n  date : Date;\n  time : number;\n  readingStatus: ReadingStatusEnum;\n}\n\nexport type ProcessedEntry = Entry & ExtraFields;\n\nexport interface Processor {\n  reset: () => void;\n  headerFound: (line:string[]) => boolean;\n  processLine:(line:string[]) => ProcessedEntry | null;\n}","import {ReadingStatusEnum, ProcessedEntry, Processor} from \"./Types\";\n\nconst fileTypes: FileType[] = [\n  {\n    headerFields: [\"date\", \"time\", \"usage not yet billed\", \"usage already billed\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]) + parseBlankFloat(line[3]),\n      kWhOut: (line) => parseFloat(line[4])\n    }\n  },\n  {\n    headerFields: [\"date\", \"time\", \"off peak\", \"peak\", \"super offpeak\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]) + parseBlankFloat(line[3]) + parseBlankFloat(line[4]),\n      kWhOut: (line) => 0\n    }\n  },\n  {\n    headerFields: [\"date\", \"time\", \"off peak(am)\", \"super off peak\", \"peak\", \"off-peak\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]) + parseBlankFloat(line[3]) + parseBlankFloat(line[4]) + parseBlankFloat(line[5]),\n      kWhOut: (line) => 0\n    }\n  },\n  {\n    headerFields: [\"date\", \"time\", \"kwh\", \"kw\", \"kva\", \"power factor\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]),\n      kWhOut: (line) => 0\n    }\n  }\n]\n\ntype FileType = {\n  headerFields: string[],\n  mapping: MappingIndexes\n}\n\ntype MappingIndexes = {\n  date: (line:string[]) => Date,\n  time: (line:string[]) => number,\n  kWhIn: (line:string[]) => number,\n  kWhOut: (line:string[]) => number\n}\n\nfunction parseDate(string: string):Date {\n  const parts = string.split(\"/\");\n  const theDate = new Date();\n  theDate.setFullYear(\n    parseInt(parts[2], 10),\n    parseInt(parts[1], 10) - 1,\n    parseInt(parts[0], 10)\n  );\n  theDate.setHours(0, 0, 1, 0);\n  return theDate;\n}\n\nfunction parseTime(string: string):number {\n  const parts = string.split(\":\");\n  let time = parseInt(parts[0], 10);\n  if (parts[1] === \"30\") time += 0.5;\n  return time;\n}\n\nfunction parseStatus(string: string):ReadingStatusEnum {\n  switch(string.toLowerCase()) {\n    case \"actual\": return ReadingStatusEnum.Actual;\n    default: return ReadingStatusEnum.Unknown;\n  }\n}\n\nfunction parseBlankFloat(string: string): number {\n  const parsedVal = parseFloat(string)\n  return Number.isFinite(parsedVal) ? parsedVal : 0;\n}\n\nfunction headerMatches(headerFields: string[], line: string[]) : [matches: boolean, generationIndex: number, statusIndex: number] {\n  let generationIndex = -1;\n  let statusIndex = -1;\n\n  if (line.length < headerFields.length) return [false, generationIndex, statusIndex];\n\n  for (let index = 0; index < line.length; index++) {\n    const fieldName = line[index].toLowerCase();\n    if (fieldName === \"generation\") {\n      generationIndex = index;\n      continue;\n    }\n\n    if (index < headerFields.length && fieldName !== headerFields[index]) {\n      return [false, generationIndex, statusIndex];\n    } else {\n      statusIndex = index;\n    }\n  }\n\n  return [true, generationIndex, statusIndex];\n}\n\nexport class SynergyProcessor implements Processor {\n  private currentFileType:FileType | null = null;\n  private generationIndex:number = -1;\n  private statusIndex:number = -1;\n\n  public reset() {\n    this.currentFileType = null;\n    this.generationIndex = -1;\n  }\n\n  public headerFound(line:string[]): boolean {\n    for (const fileType of fileTypes) {\n      const [matches, generationIndex, statusIndex] = headerMatches(fileType.headerFields, line)\n      if (!matches) continue;\n      this.currentFileType = fileType;\n      this.generationIndex = generationIndex;\n      this.statusIndex = statusIndex;\n      return true;\n    }\n    return false;\n  }\n\n  public processLine(line:string[]): ProcessedEntry | null {\n    if (this.currentFileType == null) return null;\n    const mapping = this.currentFileType.mapping;\n    const kWhOut = this.generationIndex === -1 ? 0 : parseBlankFloat(line[this.generationIndex]);\n    const status = this.statusIndex === -1 ? ReadingStatusEnum.Unknown : parseStatus(line[this.statusIndex])\n    return {\n      date: mapping.date(line),\n      time: mapping.time(line),\n      kWhIn: mapping.kWhIn(line),\n      kWhOut: kWhOut,\n      readingStatus: status,\n    }\n  }\n}","import {SynergyProcessor} from './format/Synergy'\n\nimport {ProcessedEntry, Processor} from \"./format/Types\";\n\nexport type {ProcessedEntry} from \"./format/Types\";\n\nconst LFVal:number = 0x0A;\nconst CRVal:number = 0x0D;\n\nconst sendRecordsNum = 100;\nconst decoder = new TextDecoder();\n\nconst processors:Processor[] = [\n  new SynergyProcessor(),\n];\n\ntype State = {\n  busy : boolean,\n  currentFile : string | null,\n}\n\nconst state:State = {\n  busy: false,\n  currentFile: null,\n};\n\nexport enum MessageType {\n  Unknown,\n  ImportStart,\n  ImportEnd,\n  NewRecords,\n  Error,\n}\n\nexport type Message = ReturnType<\n  typeof errorMessage | typeof importStart | typeof importEnd | typeof importedRecords\n>\n\nfunction errorMessage(error:string) {\n  return {\n    type: MessageType.Error,\n    error: error,\n  } as const;\n}\n\nfunction importStart() {\n  return {\n    type: MessageType.ImportStart,\n  } as const;\n}\n\nfunction importEnd() {\n  return {\n    type: MessageType.ImportEnd,\n  } as const;\n}\n\nfunction importedRecords(records:ProcessedEntry[], recordNumber: number) {\n  return {\n    type: MessageType.NewRecords,\n    records: records,\n    recordNumber: recordNumber,\n  } as const;\n}\n\nfunction postMessage(message:Message) {\n  // eslint-disable-next-line no-restricted-globals\n  self.postMessage(message);\n}\n\nasync function ReadData(reader:ReadableStreamDefaultReader<Uint8Array>) {\n  const recordArray: ProcessedEntry[] = Array(0);\n  let recordCount = 0;\n  let remainingBuffer: Uint8Array | null = null;\n  let currentLineBuffer: string | null = null;\n  let currentProcessor: Processor | null = null;\n\n  let keepReading = true;\n  while (keepReading) {\n    let newRead = await reader.read()\n    if (newRead.done) keepReading = false;\n    if (newRead.value === undefined) continue;\n    const newData = newRead.value;\n\n    let offset = 0;\n    let index = 0;\n    let sawCR = false;\n    if (newData.length === 0) continue;\n    while (index <= newData.length) {\n      switch (newData[index]) {\n        case CRVal:\n          sawCR = true;\n          break;\n        case LFVal:\n          let decodeArray: Uint8Array;\n          if (remainingBuffer != null) {\n            decodeArray = new Uint8Array(remainingBuffer.length + (sawCR ? index - 1 : index - offset));\n            decodeArray.set(remainingBuffer, 0);\n            decodeArray.set(newData.subarray(offset, sawCR ? index - 1 : index), remainingBuffer.length);\n            remainingBuffer = null;\n          } else {\n            decodeArray = newData.subarray(offset, sawCR ? index - 1 : index);\n          }\n          if (offset < index) currentLineBuffer = decoder.decode(decodeArray);\n          offset = index + 1;\n          sawCR = false;\n          break;\n      }\n      index++;\n      if (currentLineBuffer == null) continue;\n      currentLineBuffer = currentLineBuffer.replaceAll(\"\\\"\", \"\");\n      currentLineBuffer = currentLineBuffer.toLowerCase();\n      const currentLine = currentLineBuffer.split(\",\");\n      currentLineBuffer = null;\n\n      if (currentProcessor == null) {\n        for (const processor of processors) {\n          if (processor.headerFound(currentLine)) {\n            currentProcessor = processor;\n          }\n        }\n      } else {\n        const newRecord = currentProcessor.processLine(currentLine);\n        if (newRecord != null) recordArray.push(newRecord);\n      }\n\n    }\n    if (offset < index) remainingBuffer = newData.subarray(offset, index);\n    if (recordArray.length < sendRecordsNum) continue;\n    postMessage(importedRecords(recordArray, recordCount));\n    recordCount += recordArray.length;\n    recordArray.splice(0);\n  }\n\n  if (recordArray.length === 0) return;\n  postMessage(importedRecords(recordArray, recordCount));\n}\n\nfunction StartImport(file:File) {\n  if (state.busy) {\n    postMessage(errorMessage(\"Currently Busy\"));\n    return;\n  }\n\n  postMessage(importStart());\n  state.busy = true;\n  state.currentFile = file.name;\n\n  ReadData(file.stream().getReader()).finally(() => {\n    state.busy = false;\n    postMessage(importEnd());\n    state.currentFile = null;\n  })\n}\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = (e: MessageEvent<File>) => {\n  if (typeof(e.data.stream) === \"function\") {\n    StartImport(e.data);\n  }\n}\n\nexport {};"],"names":["ReadingStatusEnum","fileTypes","headerFields","mapping","date","line","parseDate","time","parseTime","kWhIn","parseBlankFloat","kWhOut","parseFloat","string","parts","split","theDate","Date","setFullYear","parseInt","setHours","parsedVal","Number","isFinite","headerMatches","generationIndex","statusIndex","length","index","fieldName","toLowerCase","LFVal","CRVal","sendRecordsNum","decoder","TextDecoder","processors","constructor","currentFileType","reset","this","headerFound","fileType","matches","processLine","status","Unknown","Actual","readingStatus","state","busy","currentFile","MessageType","importedRecords","records","recordNumber","type","NewRecords","postMessage","message","self","StartImport","file","error","Error","ImportStart","name","async","reader","recordArray","Array","recordCount","remainingBuffer","currentLineBuffer","currentProcessor","keepReading","newRead","read","done","undefined","value","newData","offset","sawCR","decodeArray","Uint8Array","set","subarray","decode","replaceAll","currentLine","processor","newRecord","push","splice","ReadData","stream","getReader","finally","ImportEnd","onmessage","e","data"],"sourceRoot":""}