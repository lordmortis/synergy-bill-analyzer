{"version":3,"file":"static/js/199.6e82369c.chunk.js","mappings":"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","sources":["worker/format/Types.ts","worker/format/Synergy.ts","worker/ImportWorker.ts"],"sourcesContent":["export enum ReadingStatusEnum {\n  unknown,\n  actual\n}\n\nexport type Entry = {\n  date : Date;\n  time : number;\n  kWhIn : number;\n  kWhOut : number;\n  readingStatus: ReadingStatusEnum;\n}\n\nexport interface Processor {\n  reset: () => void;\n  headerFound: (line:string[]) => boolean;\n  processLine:(line:string[]) => Entry | null;\n}","import * as Utils from './Types'\nimport {ReadingStatusEnum, Entry, Processor} from \"./Types\";\n\nconst fileTypes: FileType[] = [\n  {\n    headerFields: [\"date\", \"time\", \"usage not yet billed\", \"usage already billed\", \"generation\", \"meter reading status\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]) + parseBlankFloat(line[3]),\n      kWhOut: (line) => parseFloat(line[4]),\n      status: (line) => parseStatus(line[5]),\n    }\n  },\n  {\n    headerFields: [\"date\", \"time\", \"off peak\", \"peak\", \"super offpeak\", \"meter reading status\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]) + parseBlankFloat(line[3]) + parseBlankFloat(line[4]),\n      kWhOut: (line) => 0,\n      status: (line) => parseStatus(line[5]),\n    }\n  },\n  {\n    headerFields: [\"date\", \"time\", \"off peak(am)\", \"super off peak\", \"peak\", \"off-peak\", \"meter reading status\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]) + parseBlankFloat(line[3]) + parseBlankFloat(line[4]) + parseBlankFloat(line[5]),\n      kWhOut: (line) => 0,\n      status: (line) => parseStatus(line[6]),\n    }\n  },\n  {\n    headerFields: [\"date\", \"time\", \"kwh\", \"kw\", \"kva\", \"power factor\", \"reading status\"],\n    mapping: {\n      date: (line) => parseDate(line[0]),\n      time: (line) => parseTime(line[1]),\n      kWhIn: (line) => parseBlankFloat(line[2]),\n      kWhOut: (line) => 0,\n      status: (line) => parseStatus(line[6]),\n    }\n  }\n]\n\ntype FileType = {\n  headerFields: string[],\n  mapping: MappingIndexes\n}\n\ntype MappingIndexes = {\n  date: (line:string[]) => Date,\n  time: (line:string[]) => number,\n  kWhIn: (line:string[]) => number,\n  kWhOut: (line:string[]) => number,\n  status: (line:string[]) => Utils.ReadingStatusEnum,\n}\n\nfunction parseDate(string: string):Date {\n  const parts = string.split(\"/\");\n  const theDate = new Date();\n  theDate.setFullYear(\n    parseInt(parts[2], 10),\n    parseInt(parts[1], 10) - 1,\n    parseInt(parts[0], 10)\n  );\n  theDate.setHours(0, 0, 1, 0);\n  return theDate;\n}\n\nfunction parseTime(string: string):number {\n  const parts = string.split(\":\");\n  let time = parseInt(parts[0], 10);\n  if (parts[1] === \"30\") time += 0.5;\n  return time;\n}\n\nfunction parseStatus(string: string):ReadingStatusEnum {\n  switch(string.toLowerCase()) {\n    case \"actual\": return ReadingStatusEnum.actual;\n    default: return ReadingStatusEnum.unknown;\n  }\n}\n\nfunction parseBlankFloat(string: string): number {\n  const parsedVal = parseFloat(string)\n  return Number.isFinite(parsedVal) ? parsedVal : 0;\n}\n\nfunction headerMatches(headerFields: string[], line: string[]) {\n  for (let index = 0; index < headerFields.length; index++) {\n    if (line[index].toLowerCase() !== headerFields[index]) return false;\n  }\n  return true;\n}\n\nexport default class implements Processor {\n  private currentFileType: FileType | null = null;\n\n  public reset() {\n    this.currentFileType = null;\n  }\n\n  public headerFound(line:string[]): boolean {\n    for (const fileType of fileTypes) {\n      if (headerMatches(fileType.headerFields, line)) {\n        this.currentFileType = fileType;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public processLine(line:string[]): Entry | null {\n    if (this.currentFileType == null) return null;\n    const mapping = this.currentFileType.mapping;\n    return {\n      date: mapping.date(line),\n      time: mapping.time(line),\n      kWhIn: mapping.kWhIn(line),\n      kWhOut: mapping.kWhOut(line),\n      readingStatus: mapping.status(line),\n    }\n  }\n}","import SynergyProcessor from './format/Synergy'\n\nimport {Entry, Processor} from \"./format/Types\";\nimport {debug} from \"node:util\";\n\nexport type {Entry} from \"./format/Types\";\n\nconst LFVal:number = 0x0A;\nconst CRVal:number = 0x0D;\n\nconst sendRecordsNum = 100;\nconst decoder = new TextDecoder();\n\nconst processors:Processor[] = [\n  new SynergyProcessor(),\n];\n\ntype State = {\n  busy : boolean,\n  currentFile : string | null,\n}\n\nconst state:State = {\n  busy: false,\n  currentFile: null,\n};\n\nexport enum MessageType {\n  Unknown,\n  ImportStart,\n  ImportEnd,\n  NewRecords,\n  Error,\n}\n\nexport type Message = ReturnType<\n  typeof errorMessage | typeof importStart | typeof importEnd | typeof importedRecords\n>\n\nfunction errorMessage(error:string) {\n  return {\n    type: MessageType.Error,\n    error: error,\n  } as const;\n}\n\nfunction importStart() {\n  return {\n    type: MessageType.ImportStart,\n  } as const;\n}\n\nfunction importEnd() {\n  return {\n    type: MessageType.ImportEnd,\n  } as const;\n}\n\nfunction importedRecords(records:Entry[], recordNumber: number) {\n  return {\n    type: MessageType.NewRecords,\n    records: records,\n    recordNumber: recordNumber,\n  } as const;\n}\n\nfunction postMessage(message:Message) {\n  // eslint-disable-next-line no-restricted-globals\n  self.postMessage(message);\n}\n\nasync function ReadData(reader:ReadableStreamDefaultReader<Uint8Array>) {\n  const recordArray: Entry[] = Array(0);\n  let recordCount = 0;\n  let remainingBuffer: Uint8Array | null = null;\n  let currentLineBuffer: string | null = null;\n  let currentProcessor: Processor | null = null;\n\n  let keepReading = true;\n  while (keepReading) {\n    let newRead = await reader.read()\n    if (newRead.done) keepReading = false;\n    if (newRead.value === undefined) continue;\n    const newData = newRead.value;\n\n    let offset = 0;\n    let index = 0;\n    let sawCR = false;\n    if (newData.length === 0) continue;\n    while (index <= newData.length) {\n      switch (newData[index]) {\n        case CRVal:\n          sawCR = true;\n          break;\n        case LFVal:\n          let decodeArray: Uint8Array;\n          if (remainingBuffer != null) {\n            decodeArray = new Uint8Array(remainingBuffer.length + (sawCR ? index - 1 : index - offset));\n            decodeArray.set(remainingBuffer, 0);\n            decodeArray.set(newData.subarray(offset, sawCR ? index - 1 : index), remainingBuffer.length);\n            remainingBuffer = null;\n          } else {\n            decodeArray = newData.subarray(offset, sawCR ? index - 1 : index);\n          }\n          if (offset < index) currentLineBuffer = decoder.decode(decodeArray);\n          offset = index + 1;\n          sawCR = false;\n          break;\n      }\n      index++;\n      if (currentLineBuffer == null) continue;\n      currentLineBuffer = currentLineBuffer.replaceAll(\"\\\"\", \"\");\n      currentLineBuffer = currentLineBuffer.toLowerCase();\n      const currentLine = currentLineBuffer.split(\",\");\n      currentLineBuffer = null;\n\n      if (currentProcessor == null) {\n        for (const processor of processors) {\n          if (processor.headerFound(currentLine)) {\n            currentProcessor = processor;\n          }\n        }\n      } else {\n        const newRecord = currentProcessor.processLine(currentLine);\n        if (newRecord != null) recordArray.push(newRecord);\n      }\n\n    }\n    if (offset < index) remainingBuffer = newData.subarray(offset, index);\n    if (recordArray.length < sendRecordsNum) continue;\n    postMessage(importedRecords(recordArray, recordCount));\n    recordCount += recordArray.length;\n    recordArray.splice(0);\n  }\n\n  if (recordArray.length === 0) return;\n  postMessage(importedRecords(recordArray, recordCount));\n}\n\nfunction StartImport(file:File) {\n  if (state.busy) {\n    postMessage(errorMessage(\"Currently Busy\"));\n    return;\n  }\n\n  postMessage(importStart());\n  state.busy = true;\n  state.currentFile = file.name;\n\n  ReadData(file.stream().getReader()).finally(() => {\n    state.busy = false;\n    postMessage(importEnd());\n    state.currentFile = null;\n  })\n}\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = (e: MessageEvent<File>) => {\n  if (typeof(e.data.stream) === \"function\") {\n    StartImport(e.data);\n  }\n}\n\nexport {};"],"names":["ReadingStatusEnum","fileTypes","headerFields","mapping","date","line","parseDate","time","parseTime","kWhIn","parseBlankFloat","kWhOut","parseFloat","status","parseStatus","string","parts","split","theDate","Date","setFullYear","parseInt","setHours","toLowerCase","actual","unknown","parsedVal","Number","isFinite","headerMatches","index","length","LFVal","CRVal","sendRecordsNum","decoder","TextDecoder","processors","constructor","currentFileType","reset","this","headerFound","fileType","processLine","readingStatus","state","busy","currentFile","MessageType","importedRecords","records","recordNumber","type","NewRecords","postMessage","message","self","StartImport","file","error","Error","ImportStart","name","async","reader","recordArray","Array","recordCount","remainingBuffer","currentLineBuffer","currentProcessor","keepReading","newRead","read","done","undefined","value","newData","offset","sawCR","decodeArray","Uint8Array","set","subarray","decode","replaceAll","currentLine","processor","newRecord","push","splice","ReadData","stream","getReader","finally","ImportEnd","onmessage","e","data"],"sourceRoot":""}